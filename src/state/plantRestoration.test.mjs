/**
 * @jest-environment node
 */
import { jest } from "@jest/globals";

// Mock global Worker for Node environment
global.Worker = class {
  constructor() {}
  postMessage() {}
  terminate() {}
  onmessage() {}
};

// Mock dependencies
jest.unstable_mockModule("../util/chunk.mjs", () => {
  const CHUNK_SIZE_X = 16;
  const CHUNK_SIZE_Y = 128;
  const CHUNK_SIZE_Z = 16;
  const CHUNK_VOLUME = CHUNK_SIZE_X * CHUNK_SIZE_Y * CHUNK_SIZE_Z;

  class MockChunk {
    constructor(chunkX, chunkZ) {
      this.chunkX = chunkX;
      this.chunkZ = chunkZ;
      this.blocks = new Uint8Array(CHUNK_VOLUME);
      this.dirty = true;
      this.generated = false;
      this.mesh = null;
      this.modifiedBlocks = new Map();
      this.worldX = chunkX * CHUNK_SIZE_X;
      this.worldZ = chunkZ * CHUNK_SIZE_Z;
    }

    index(x, y, z) {
      return x + z * CHUNK_SIZE_X + y * CHUNK_SIZE_X * CHUNK_SIZE_Z;
    }

    inBounds(x, y, z) {
      return (
        x >= 0 &&
        x < CHUNK_SIZE_X &&
        y >= 0 &&
        y < CHUNK_SIZE_Y &&
        z >= 0 &&
        z < CHUNK_SIZE_Z
      );
    }

    getBlock(x, y, z) {
      if (!this.inBounds(x, y, z)) return 0;
      return this.blocks[this.index(x, y, z)];
    }

    setBlock(x, y, z, type) {
      if (!this.inBounds(x, y, z)) return false;
      this.blocks[this.index(x, y, z)] = type;
      this.dirty = true;
      return true;
    }

    markModified(x, y, z, type) {
      if (!this.inBounds(x, y, z)) return;
      this.modifiedBlocks.set(this.index(x, y, z), type);
    }

    getModifications() {
      return this.modifiedBlocks;
    }

    applyModifications(mods) {
      for (const [idx, type] of mods) {
        this.blocks[idx] = type;
      }
      this.modifiedBlocks = new Map(mods);
      this.dirty = true;
    }
  }

  return {
    Chunk: MockChunk,
    CHUNK_SIZE_X,
    CHUNK_SIZE_Y,
    CHUNK_SIZE_Z,
    worldToChunk: (worldX, worldZ) => {
      const chunkX = Math.floor(worldX / CHUNK_SIZE_X);
      const chunkZ = Math.floor(worldZ / CHUNK_SIZE_Z);
      const localX = ((worldX % CHUNK_SIZE_X) + CHUNK_SIZE_X) % CHUNK_SIZE_X;
      const localZ = ((worldZ % CHUNK_SIZE_Z) + CHUNK_SIZE_Z) % CHUNK_SIZE_Z;
      return { chunkX, chunkZ, localX, localZ };
    },
  };
});

const { ChunkManager } = await import("./chunkManager.mjs");
const { gameConfig } = await import("./config/index.mjs");

describe("Plant Restoration Fix", () => {
  let manager;
  const deleteChunkMesh = jest.fn();

  beforeEach(() => {
    manager = new ChunkManager();
    gameConfig.renderRadius.set(1);
    gameConfig.cacheRadius.set(2);
    deleteChunkMesh.mockClear();
  });

  test("should NOT filter out plant growth blocks upon restoration", () => {
    const growthTimers = {};
    const plantStructures = {};

    // 1. Initial load
    manager.updateVisibleChunks(
      0,
      0,
      123,
      {},
      deleteChunkMesh,
      growthTimers,
      plantStructures,
    );

    // 2. Simulate a grown plant at (5, 10, 5)
    // In a real game, these blocks would be in the world.
    // Here we simulate the metadata HAVING blocks.
    const key = "5,10,5";
    growthTimers[key] = 5.0;
    plantStructures[key] = {
      type: "Sunflower",
      blocks: [
        { x: 5, y: 10, z: 5, blockId: 100 },
        { x: 5, y: 11, z: 5, blockId: 101 },
      ],
    };

    // 3. Unload chunk
    manager.updateVisibleChunks(
      100,
      100,
      123,
      {},
      deleteChunkMesh,
      growthTimers,
      plantStructures,
    );

    // Verify it's stored
    expect(manager.storedPlantStates.has("0,0")).toBe(true);
    expect(growthTimers[key]).toBeUndefined();
    expect(plantStructures[key]).toBeUndefined();

    // 4. Reload chunk
    manager.updateVisibleChunks(
      0,
      0,
      123,
      {},
      deleteChunkMesh,
      growthTimers,
      plantStructures,
    );

    // Simulate chunk being generated by worker
    const chunk = manager.getChunk(0, 0);
    chunk.generated = true;

    // Trigger restoration
    manager.updateVisibleChunks(
      0,
      0,
      123,
      {},
      deleteChunkMesh,
      growthTimers,
      plantStructures,
    );

    // Verify it's restored WITHOUT being filtered out
    expect(plantStructures[key]).toBeDefined();
    expect(plantStructures[key].blocks.length).toBe(2);
    expect(plantStructures[key].blocks[0].x).toBe(5);
    expect(plantStructures[key].blocks[1].y).toBe(11);
  });

  test("should handle initial seeds with string coordinate blocks in updateStructure", async () => {
    const { updateStructure } = await import("../update/plantGrowth.mjs");
    const growthTimers = {};
    const plantStructures = {};

    const key = "10,20,10";
    plantStructures[key] = {
      type: "Mushroom",
      blocks: [key], // Initial seed format (string key)
    };

    // Mock world.set and world.delete
    manager.set = jest.fn();
    manager.delete = jest.fn();
    manager.get = jest.fn().mockReturnValue(123); // Simulate block exists

    const state = {
      world: manager,
      plantStructures,
      growthTimers,
      fastGrowth: true,
    };

    // This should not throw and should call delete on the string key
    updateStructure(state, key, 0.5, "Mushroom");

    expect(manager.delete).toHaveBeenCalledWith(key);
    expect(plantStructures[key].blocks.length).toBeGreaterThan(0);
    expect(typeof plantStructures[key].blocks[0]).toBe("object");
  });
});
